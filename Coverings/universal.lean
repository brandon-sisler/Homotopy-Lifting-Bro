import Mathlib.Topology.Homotopy.Path
import Mathlib.Topology.PathConnected
import Mathlib.Topology.Bases
import Mathlib.Topology.Basic
open Set Topology

variable {X : Type _} [TopologicalSpace X] (x‚ÇÄ : X) {x‚ÇÅ : X }

-- #synth TopologicalSpace (Path x‚ÇÄ x‚ÇÅ)

open TopologicalSpace
open ContinuousMap
 
def inc_path {X: Type _} [TopologicalSpace X] 
         (U: Set X) (x y: U) (p : Path x y): Path (x:X) (y:X) where
      toFun t := p t
      continuous_toFun := by continuity --p.continuous_toFun  
      source' := by simp
      target' := by simp

def slsc_subspace {X: Type _} [TopologicalSpace X](x:X)(U: Set X) : Prop :=
  ‚àÉ (hx : x ‚àà U), ‚àÄ p : Path (X := U) ‚ü®x, hx‚ü© ‚ü®x, hx‚ü©, Path.Homotopic (inc_path _ _ _ p) (Path.refl _) 

lemma subset_slsc_is_slsc {X: Type _} [TopologicalSpace X] (x:X){U V: Set X} (slscU: slsc_subspace x U) (VU: V ‚äÜ U)(xinV: x ‚àà V):
  slsc_subspace x V := by sorry 

def slsc_pc_subspace {X: Type _} [TopologicalSpace X] (U: Set X) : Prop :=
  ‚àÉ x, slsc_subspace x U ‚àß IsPathConnected U ‚àß U.Nonempty

class slsc_space (X: Type _)[TopologicalSpace X] where
   slsc_nbhd_exists : ‚àÄ x : X, ‚àÉ U : Set X, IsOpen U ‚àß  slsc_subspace x U 

-- Define the potential basis whose elements are slsc and path connected
def slsc_pc_nbhds (X: Type _)[TopologicalSpace X]: Set (Set X):= 
  { U : Set X | IsOpen U ‚àß slsc_pc_subspace U } 

-- To show that the slsc and path connected collection is a basis when X is a locally path connected space
lemma slsc_pc_nbhds_is_basis {X: Type _}[TopologicalSpace X][lpc: LocPathConnectedSpace X][slsc: slsc_space X]:
  IsTopologicalBasis (slsc_pc_nbhds X) :=by 
  apply isTopologicalBasis_of_open_of_nhds

  . intro U Uslpc
    exact Uslpc.1

  . intro a U ainU openU
    rcases slsc_space.slsc_nbhd_exists a with ‚ü® W , ‚ü®openW, ‚ü® ainW , slsc_condition ‚ü© ‚ü© ‚ü© 
    
    have openUW : IsOpen (U ‚à© W):= TopologicalSpace.isOpen_inter U W openU openW
    -- have slscUW : slsc_subspace a (U ‚à© W):= by sorry
    have ainUW : a ‚àà U ‚à© W := ‚ü® ainU , ainW ‚ü© 
    have UW_in : (U ‚à© W) ‚àà ùìù a := openUW.mem_nhds ainUW
    have this:= (path_connected_basis a).mem_iff.mp UW_in 
    rcases this with ‚ü®V, ‚ü®V_in, hV‚ü©, hVU : V ‚äÜ U ‚à© W‚ü©
    have new:= mem_nhds_iff.mp V_in 
    rcases new with ‚ü®S, ‚ü® hSV, openS, ainS ‚ü© ‚ü©
    have slscS : slsc_subspace a S:= by sorry
    use S
    constructor 
    . constructor
      exact openS
      use a
      


    . constructor
      exact ainS
      intro x xs
      exact (hVU (hSV xs)).1
      
      -- have : S ‚äÜ U := by  
      -- exact ‚ü® ainS, ‚ü© 
    --have U_in : U ‚àà ùìù a := openU.mem_nhds ainU 
    --rcases(path_connected_basis a).mem_iff.mp U_in with ‚ü®V, ‚ü®V_in, hV‚ü©, hVU : V ‚äÜ U‚ü©

noncomputable
def get_point {X: Type _} (U : Set  X) (h : U.Nonempty) : X := h.choose

lemma slsc_nbhd_is_nonempty (X : Type _) [TopologicalSpace X] (U : slsc_pc_nbhds X) : U.1.Nonempty :=
  sorry

-- The universal cover is defined to be the quotient of the path space of X modulo the equivalence relation generated     
def UniversalCover (X: Type _) [TopologicalSpace X] (x‚ÇÄ : X) :=
  Œ£ x‚ÇÅ : X , Path.Homotopic.Quotient x‚ÇÄ x‚ÇÅ

def temp (X: Type _)[TopologicalSpace X] ( x‚ÇÄ : X ) (U : slsc_pc_nbhds X) ( Œ≥ : Path x‚ÇÄ (get_point U (slsc_nbhd_is_nonempty X U ) )) (u : U.1) : UniversalCover X x‚ÇÄ :=
  

  -- try to get the specific Œ≥‚ÇÅ on its own so that we can use get_all_local_compositions together as a set
  -- Œ£ u : U, { Œ≥‚ÇÅ : UniversalCover X x‚ÇÄ | ‚àÉ Œ≥‚ÇÄ : Path ( get_point U )  u , Œ≥‚ÇÅ =  ‚ü® _ , ‚ü¶ Œ≥.trans ( inc_path U ( get_point U ) u Œ≥‚ÇÄ ) ‚üß ‚ü© }
  --thingy := ‚ü® x‚ÇÄ , test ‚ü©
  sorry

def all_local_compositions (X: Type _)[TopologicalSpace X] ( x‚ÇÄ : X ) (U : slsc_pc_nbhds X) ( Œ≥ : Path x‚ÇÄ (get_point U (slsc_nbhd_is_nonempty X U ))): Set ( UniversalCover X x‚ÇÄ ) := 
  temp X x‚ÇÄ U Œ≥ '' Set.univ 

#check fun p : Œ£ (U : slsc_pc_nbhds X), Path x‚ÇÄ (get_point U (slsc_nbhd_is_nonempty X U ) ) ‚Ü¶  all_local_compositions X x‚ÇÄ p.1 p.2 

-- lifts_of_slsc_pc_nbhds creates a collection of subsets of the universal cover which correspond
-- to each homotopy equivalence class of paths
def lifts_of_slsc_pc_nbhds (X : Type _) [TopologicalSpace X ] (x‚ÇÄ : X) 
 -- ( U : slsc_pc_nbhds X) ( Œ≥ : Path x‚ÇÄ ( get_point U ) ) 
 : Set (Set (UniversalCover X x‚ÇÄ)) :=
  range (fun p : Œ£ (U : slsc_pc_nbhds X), Path x‚ÇÄ (get_point U (slsc_nbhd_is_nonempty X U ) ) ‚Ü¶  all_local_compositions X x‚ÇÄ p.1 p.2)

instance (X : Type _) [TopologicalSpace X] [LocPathConnectedSpace X] [slsc_space X] (x‚ÇÄ : X) : TopologicalSpace (UniversalCover X x‚ÇÄ) :=  
  generateFrom (lifts_of_slsc_pc_nbhds X x‚ÇÄ)

lemma lifts_of_slsc_pc_nbhds_is_basis {X: Type _} [TopologicalSpace X] [lpc: LocPathConnectedSpace X] [slsc: slsc_space X] (x‚ÇÄ : X) (Y : UniversalCover X x‚ÇÄ) :
  IsTopologicalBasis (lifts_of_slsc_pc_nbhds X x‚ÇÄ) := by sorry 
  -- apply isTopologicalBasis_of_open_of_nhds
--     sorry
--   sorry  

